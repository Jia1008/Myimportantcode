package com.briup.ThreadPool;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class UserThreadPoolExecutor {
	
	public static void main(String[] args) {
		/**
		 * 在使用有界队列时，若有新的任务需要执行，如果线程池实际线程数小于corePoolSize，则优先创建线程
		 * 若大于corePoolSize，则会将任务加入队列
		 * 若队列已满，则在线程数不大于maxnumPoolSize的前提下，创建新的线程
		 * 若线程数大于maxnumPoolSize,则执行拒绝策略，或其他自定义方式
		 */
		
		ThreadPoolExecutor pool=new ThreadPoolExecutor(
				1,  		//核心线程
				2, 			//最大队列
				60, 		//60
				TimeUnit.SECONDS,
				new ArrayBlockingQueue<Runnable>(3)  //有界队列
				//new LinkedBlockingQueue<Runnable>()    //无界队列
				//, new DiscardOldestPolicy() 
				, new MyRejected()				//自定义拒绝策略
				);
		
		MyTask mt1=new MyTask(1, "任务1");
		MyTask mt2=new MyTask(2, "任务2");
		MyTask mt3=new MyTask(3, "任务3");
		MyTask mt4=new MyTask(4, "任务4");
		MyTask mt5=new MyTask(5, "任务5");
		//MyTask mt6=new MyTask(6, "任务6");
		
		pool.execute(mt1);
		pool.execute(mt2);
		pool.execute(mt3);
		pool.execute(mt4);
		pool.execute(mt5);
		//pool.execute(mt6);
		
		pool.shutdown();//停止线程池
	}
}
